<?php
/*-------------------------------------------------------+
| Project 60 - CiviBanking                               |
| Copyright (C) 2013-2018 SYSTOPIA                       |
| Author: B. Endres (endres -at- systopia.de)            |
| http://www.systopia.de/                                |
+--------------------------------------------------------+
| This program is released as free software under the    |
| Affero GPL v3 license. You can redistribute it and/or  |
| modify it under the terms of this license which you    |
| can read by viewing the included agpl.txt or online    |
| at www.gnu.org/licenses/agpl.html. Removal of this     |
| copyright header is strictly prohibited without        |
| written permission from the original author(s).        |
+--------------------------------------------------------*/

declare(strict_types = 1);

use CRM_Banking_ExtensionUtil as E;

/**
 * phpcs:disable Generic.NamingConventions.AbstractClassNamePrefix.Missing
 */
abstract class CRM_Banking_PluginModel_Matcher extends CRM_Banking_PluginModel_BtxBase {

  protected static $_cache = NULL;

  protected $_suggestions;

  protected function addSuggestion($suggestion) {
    $this->_suggestions[] = $suggestion;
  }

  // ------------------------------------------------------
  // Functions to be provided by the plugin implementations
  // ------------------------------------------------------

  /**
   * Report if the plugin is capable of batch matching (v2+?)
   *
   * @return bool
   */
  public function does_batch_matching() {
    return FALSE;
  }

  /**
   * Generate a set of suggestions for the given bank transaction
   *
   * @return array(match structures)
   */
  abstract public function match(CRM_Banking_BAO_BankTransaction $btx, CRM_Banking_Matcher_Context $context);

  /**
   * Executes a previously generated match, i.e. the suggestion is accepted and realized
   *
   * Obviously, this method should be overwritten by the individual matchers,
   *  but DON'T forget to call parent::execute($match, $btx);
   *
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return the execution result:  TRUE       successfull
   *   NULL/FALSE if not successfull
   *                                're-run'   if the analysis should be re-run (UI only)
   */
  public function execute($match, $btx) {
    $match->setExecuted();
    $btx->saveSuggestions();
    return TRUE;
  }

  /**
   * Generate html code to visualize the given match. The visualization may also provide interactive form elements.
   *
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return string html code snippet
   */
  public function visualize_match(CRM_Banking_Matcher_Suggestion $match, $btx) {
    $html = '<p>' . E::ts('Because :') . '<ul>';
    $evidence = $match->getEvidence();
    foreach ($evidence as $ev) {
      $html .= '<li>' . $ev . '</li>';
    }
    $html .= '</ul></p>';
    return $html;
  }

  /**
   * Generate html code to visualize the executed match.
   *
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return html code snippet
   */
  public function visualize_execution_info(CRM_Banking_Matcher_Suggestion $match, $btx) {
    // TODO: implement
    $s = '<p>' . E::ts('No further information available') . '</p>';
    return $s;
  }

  /**
   * If the user has modified the input fields provided by the "visualize" html code,
   * the new values will be passed here BEFORE execution
   *
   * CAUTION: there might be more parameters than provided. Only process the ones that
   *  'belong' to your suggestion.
   */
  public function update_parameters(CRM_Banking_Matcher_Suggestion $match, $parameters) {
    // Noting to do in the abstract matcher. Override for a matcher that uses input fields
  }

  /**
   * class constructor
   */
  public function __construct($plugin_dao) {
    $this->_suggestions = [];
    parent::__construct($plugin_dao);
  }

  /**
   * Returns the threshold for automatic execution as set in the config
   *
   * @return float ([0..1])
   */
  public function getThreshold() {
    if (isset($this->_plugin_config->threshold)) {
      $threshold = (float) $this->_plugin_config->threshold;
      if ($threshold >= 1.0) {
        return 1.0;
      }
      elseif ($threshold <= 0.0) {
        return 0.0;
      }
      else {
        return $threshold;
      }
    }
    return 1.0;
  }

  /**
   * Returns whether the plugin is configured to execute unsupervised
   *
   * @return bool
   */
  public function autoExecute() {
    if (isset($this->_plugin_config->auto_exec)) {
      $value = $this->_plugin_config->auto_exec;
      if ($value === TRUE || $value === 'true') {
        return 1.0;
      }
      elseif (($value >= 0.0) && ($value <= 1.0)) {
        return (float) $value;
      }
      else {
        return 0.0;
      }
    }
    else {
      return 0.0;
    }
  }

  /**************************************************************
   *                      Penalty rules                         *
   */

  /**
   * get a general penalty value to be applied to all suggestions
   * based on the 'penalties' rule set in the configuration
   *
   * phpcs:disable Generic.Metrics.CyclomaticComplexity.TooHigh
   */
  public function getPenalty($btx) {
  // phpcs:enable
    $config = $this->_plugin_config;
    if (empty($config->penalties)) {
      return 0.0;
    }
    $penalty = 0.0;

    // execute the rules
    foreach ($config->penalties as $penalty_rule) {

      if ($penalty_rule->type == 'constant') {
        // CONSTANT PENALTY
        $penalty += $penalty_rule->amount;
        $trigger_count -= 1;

      }
      elseif ($penalty_rule->type == 'suggestion') {
        // OTHER SUGGESTIONS PENALTY

        // first: see, how many times this rule should be triggered at most
        if (!empty($penalty_rule->max_trigger_count)) {
          $trigger_count = (int) $penalty_rule->max_trigger_count;
        }
        else {
          $trigger_count = 1;
        }

        foreach ($btx->getSuggestionList() as $suggestion) {
          $matcher = $suggestion->getPlugin();
          if (!empty($penalty_rule->threshold)
            && $suggestion->getProbability() < $penalty_rule->threshold) {
            continue;
          }
          if (!empty($penalty_rule->suggestion_type)
            && $matcher->getTypeName() != $penalty_rule->suggestion_type) {
            continue;
          }

          if ($trigger_count <= 0) {
            break;
          }

          // if we get here, the penalty is supposed to be applied
          $penalty += $penalty_rule->amount;
          $trigger_count -= 1;
        }

      }
      elseif ($penalty_rule->type == 'attribute') {
        // ATTRIBUTE/VARIABLE PENALTY
        if (!empty($penalty_rule->triggers)) {
          if ($this->requiredValuesPresent($btx, $penalty_rule->triggers)) {
            $penalty += $penalty_rule->amount;
          }
        }

      }
      else {
        $this->logger->logError('penalty type unknown: ' . $penalty_rule->type);
      }
    }
    return $penalty;
  }

  /**************************************************************
   *                  Store Account Data                        *
   */

  /**
   * Will store the donor's account data
   *
   * @todo move to post processors
   *
   * phpcs:disable Generic.Metrics.CyclomaticComplexity.MaxExceeded
   */
  public function storeAccountWithContact($btx, $contact_id) {
  // phpcs:enable
    // check if this has been turned off
    if (CRM_Core_BAO_Setting::getItem('CiviBanking', 'reference_store_disabled')) {
      return;
    }

    // find all reference types
    $reference_type_group = ['name' => 'civicrm_banking.reference_types'];
    $reference_types = [];
    CRM_Core_OptionValue::getValues($reference_type_group, $reference_types);

    // gather the information
    $data = $btx->getDataParsed();
    $references = [];
    foreach ($reference_types as $reference_type) {
      $field_name = '_party_' . $reference_type['name'];
      if (!empty($data[$field_name])) {
        $references[$reference_type['id']] = $data[$field_name];
      }
    }

    // if we don't have references, there's nothing we can do...
    if (empty($references)) {
      return;
    }

    // gather account info
    $account_info = [];
    if (!empty($data['_party_BIC'])) {
      $account_info['BIC'] = $data['_party_BIC'];
    }
    if (!empty($data['_party_IBAN'])) {
      $account_info['country'] = substr($data['_party_IBAN'], 0, 2);
    }
    // copy all entries that start with _party_ba_ into the account info
    foreach ($data as $key => $value) {
      if ('_party_ba_' == substr($key, 0, 10)) {
        if (!empty($value)) {
          $new_key = substr($key, 10);
          $account_info[$new_key] = $value;
        }
      }
    }

    // find all referenced bank accounts
    $bank_accounts = [];
    $contact_bank_account_id = NULL;
    $contact_bank_account_created = FALSE;
    $reference2instances = [];
    foreach ($references as $reference_type => $reference) {
      $reference2instances[$reference] = [];
      $query = ['version' => 3, 'reference' => $reference, 'reference_type_id' => $reference_type];
      $existing = civicrm_api('BankingAccountReference', 'get', $query);
      if (empty($existing['is_error'])) {
        foreach ($existing['values'] as $account_reference) {
          array_push($reference2instances[$reference], $account_reference);
          if (!isset($bank_accounts[$account_reference['ba_id']])) {
            // load the bank account
            $ba_bao = new CRM_Banking_BAO_BankAccount();
            $ba_bao->get('id', $account_reference['ba_id']);
            $bank_accounts[$account_reference['ba_id']] = $ba_bao;
          }

          // consider this bank account to be ours if the contact id matches
          if (!$contact_bank_account_id && ($ba_bao->contact_id == $contact_id)) {
            $contact_bank_account_id = $ba_bao->id;
          }
        }
      }
    }

    // create new account if it does not yet exist
    if (!$contact_bank_account_id) {
      $ba_bao = new CRM_Banking_BAO_BankAccount();
      $ba_bao->contact_id = $contact_id;
      $ba_bao->description = E::ts('created by CiviBanking');
      $ba_bao->created_date = date('YmdHis');
      $ba_bao->modified_date = date('YmdHis');
      $ba_bao->data_raw = NULL;
      $ba_bao->data_parsed = '{}';
      $ba_bao->save();

      $contact_bank_account_id = $ba_bao->id;
      $bank_accounts[$contact_bank_account_id] = $ba_bao;
      $contact_bank_account_created = TRUE;
    }

    // update bank account data
    $ba_bao = $bank_accounts[$contact_bank_account_id];
    $ba_data = $ba_bao->getDataParsed();
    foreach ($account_info as $key => $value) {
      $ba_data[$key] = $value;
    }
    $ba_bao->setDataParsed($ba_data);
    $ba_bao->save();

    // create references (warn if exists for another contact)
    foreach ($references as $reference_type => $reference) {
      // check the existing
      $reference_already_there = FALSE;
      foreach ($reference2instances[$reference] as $reference_instance) {
        if ($reference_instance['ba_id'] == $contact_bank_account_id) {
          // there is already a reference for 'our' bank account
          $reference_already_there = TRUE;
          break;
        }
      }

      if (!$reference_already_there) {
        // there was no reference to 'our' bank account -> create!
        $query = [
          'version'           => 3,
          'reference'         => $reference,
          'reference_type_id' => $reference_type,
          'ba_id'             => $contact_bank_account_id,
        ];
        $result = civicrm_api('BankingAccountReference', 'create', $query);
        if (!empty($result['is_error'])) {
          CRM_Core_Session::setStatus(
            E::ts("Couldn't create reference. Error was: '%1'", [1 => $result['error_message']]),
            E::ts('Error'),
            'alert'
          );
        }
      }
    }

    // finally, create some feedback
    if ($contact_bank_account_created) {
      if (count($bank_accounts) > 1) {
        // there are mutiple acccounts referenced by this
        $message = E::ts(
          // phpcs:disable Generic.Files.LineLength.TooLong
          'The account information of this contact was saved, but it is also used by the following contacts:<br/><ul>%s</ul>'
          // phpcs:enable
        );
        $contacts = '';
        foreach ($bank_accounts as $ba_id => $ba_bao) {
          if ($ba_id == $contact_bank_account_id) {
            continue;
          }
          $contact = civicrm_api('Contact', 'getsingle', ['version' => 3, 'id' => $ba_bao->contact_id]);
          if (empty($contact['is_error'])) {
            $url = CRM_Utils_System::url('civicrm/contact/view', 'cid=' . $ba_bao->contact_id);
            $contacts .= "<li><a href='$url'>" . $contact['display_name'] . '</a></li>';
          }
        }
        CRM_Core_Session::setStatus(sprintf($message, $contacts), E::ts('Warning'), 'warn');
      }
      else {
        CRM_Core_Session::setStatus(
          E::ts('The account information of this contact was saved.'),
          E::ts('Account saved'),
          'info'
        );
      }
    }
  }

}
