<?php
/*-------------------------------------------------------+
| Project 60 - CiviBanking                               |
| Copyright (C) 2013-2018 SYSTOPIA                       |
| Author: B. Endres (endres -at- systopia.de)            |
| http://www.systopia.de/                                |
+--------------------------------------------------------+
| This program is released as free software under the    |
| Affero GPL v3 license. You can redistribute it and/or  |
| modify it under the terms of this license which you    |
| can read by viewing the included agpl.txt or online    |
| at www.gnu.org/licenses/agpl.html. Removal of this     |
| copyright header is strictly prohibited without        |
| written permission from the original author(s).        |
+--------------------------------------------------------*/

use CRM_Banking_ExtensionUtil as E;

/**
 *
 * @package org.project60.banking
 * @copyright GNU Affero General Public License
 * $Id$
 *
 */
abstract class CRM_Banking_PluginModel_Matcher extends CRM_Banking_PluginModel_BtxBase {

  protected static $_cache = NULL;

  protected $_suggestions;

  protected function addSuggestion( $suggestion )
  {
      $this->_suggestions[] = $suggestion;
    }

  // ------------------------------------------------------
  // Functions to be provided by the plugin implementations
  // ------------------------------------------------------
  /**
   * Report if the plugin is capable of batch matching (v2+?)
   *
   * @return bool
   */
  function does_batch_matching() { return FALSE; }

  /**
   * Generate a set of suggestions for the given bank transaction
   *
   * @return array(match structures)
   */
  public abstract function match(CRM_Banking_BAO_BankTransaction $btx, CRM_Banking_Matcher_Context $context);

  /**
   * Executes a previously generated match, i.e. the suggestion is accepted and realized
   *
   * Obviously, this method should be overwritten by the individual matchers,
   *  but DON'T forget to call parent::execute($match, $btx);
   *
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return the execution result:  TRUE       successfull
   *                                NULL/FALSE if not successfull
   *                                're-run'   if the analysis should be re-run (UI only)
   */
  public function execute( $match, $btx ) {
    $match->setExecuted();
    $btx->saveSuggestions();
    return TRUE;
  }


  /**
   * Generate html code to visualize the given match. The visualization may also provide interactive form elements.
   *
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return html code snippet
   */
  function visualize_match( CRM_Banking_Matcher_Suggestion $match, $btx) {
    $html = "<p>".E::ts("Because :")."<ul>";
    $evidence = $match->getEvidence();
    foreach ($evidence as $ev) {
        $html .= '<li>' . $ev . '</li>';
    }
    $html .= '</ul></p>';
    return $html;
  }

  /**
   * Generate html code to visualize the executed match.
   *
   * @val $match    match data as previously generated by this plugin instance
   * @val $btx      the bank transaction the match refers to
   * @return html code snippet
   */
  function visualize_execution_info( CRM_Banking_Matcher_Suggestion $match, $btx) {
      // TODO: implement
      $s = '<p>'.E::ts('No further information available').'</p>';
      return $s;
  }

  /**
   * If the user has modified the input fields provided by the "visualize" html code,
   * the new values will be passed here BEFORE execution
   *
   * CAUTION: there might be more parameters than provided. Only process the ones that
   *  'belong' to your suggestion.
   */
  public function update_parameters(CRM_Banking_Matcher_Suggestion $match, $parameters) {
      // Noting to do in the abstract matcher. Override for a matcher that uses input fields
  }


  /**
   * class constructor
   */
  function __construct($plugin_dao) {
    $this->_suggestions = array();
    parent::__construct($plugin_dao);
  }

  /**
   * Returns the threshold for automatic execution as set in the config
   *
   * @return float ([0..1])
   */
  function getThreshold() {
    if (isset($this->_plugin_config->threshold)) {
      $threshold = (float) $this->_plugin_config->threshold;
      if ($threshold >= 1.0) {
        return 1.0;
      } elseif ($threshold <= 0.0) {
        return 0.0;
      } else {
        return $threshold;
      }
    }
    return 1.0;
  }

  /**
   * Returns whether the plugin is configured to execute unsupervised
   *
   * @return bool
   */
  function autoExecute() {
    if (isset($this->_plugin_config->auto_exec)) {
      $value = $this->_plugin_config->auto_exec;
      if ($value===true || $value==='true') {
        return 1.0;
      } elseif (($value >= 0.0) && ($value <= 1.0)) {
        return (float) $value;
      } else {
        return 0.0;
      }
    } else {
      return 0.0;
    }
  }




  /**************************************************************
   *                      Penalty rules                         *
   **************************************************************/

  /**
   * get a general penalty value to be applied to all suggestions
   * based on the 'penalties' rule set in the configuration
   */
  function getPenalty($btx) {
    $config = $this->_plugin_config;
    if (empty($config->penalties)) return 0.0;
    $penalty = 0.0;

    // execute the rules
    foreach ($config->penalties as $penalty_rule) {

      if ($penalty_rule->type == 'constant') {
        // CONSTANT PENALTY
        $penalty += $penalty_rule->amount;
        $trigger_count -= 1;

      } elseif ($penalty_rule->type == 'suggestion') {
        // OTHER SUGGESTIONS PENALTY

        // first: see, how many times this roule should be triggered at most
        if (!empty($penalty_rule->max_trigger_count)) {
          $trigger_count = (int) $penalty_rule->max_trigger_count;
        } else {
          $trigger_count = 1;
        }

        foreach ($btx->getSuggestionList() as $suggestion) {
          $matcher = $suggestion->getPlugin();
          if (!empty($penalty_rule->threshold)
            && $suggestion->getProbability() < $penalty_rule->threshold) continue;
          if (!empty($penalty_rule->suggestion_type)
            && $matcher->getTypeName() != $penalty_rule->suggestion_type) continue;

          if ($trigger_count <= 0) break;

          // if we get here, the penalty is supposed to be applied
          $penalty += $penalty_rule->amount;
          $trigger_count -= 1;
        }

      } elseif ($penalty_rule->type == 'attribute') {
        // ATTRIBUTE/VARIABLE PENALTY
        if (!empty($penalty_rule->triggers)) {
          if ($this->requiredValuesPresent($btx, $penalty_rule->triggers)) {
            $penalty += $penalty_rule->amount;
          }
        }

      } else {
        error_log("org.project60.banking.matcher: penalty type unknwon: " . $penalty_rule->type);
      }
    }
    return $penalty;
  }


  /**************************************************************
   *                  Store Account Data                        *
   **************************************************************/

  /**
   * Will store the donor's account data
   *
   * @todo move to post processors
   */
  function storeAccountWithContact($btx, $contact_id) {
    // check if this has been turned off
    if (CRM_Core_BAO_Setting::getItem('CiviBanking', 'reference_store_disabled')) {
      return;
    }

    // find all reference types
    $reference_type_group = array('name' => 'civicrm_banking.reference_types');
    $reference_types = array();
    CRM_Core_OptionValue::getValues($reference_type_group, $reference_types);

    // gather the information
    $data = $btx->getDataParsed();
    $references = array();
    foreach ($reference_types as $reference_type) {
      $field_name = '_party_'.$reference_type['name'];
      if (!empty($data[$field_name])) {
        $references[$reference_type['id']] = $data[$field_name];
      }
    }

    // if we don't have references, there's nothing we can do...
    if (empty($references)) return;

    // gather account info
    $account_info = array();
    if (!empty($data['_party_BIC'])) $account_info['BIC'] = $data['_party_BIC'];
    if (!empty($data['_party_IBAN'])) $account_info['country'] = substr($data['_party_IBAN'], 0, 2);
    // copy all entries that start with _party_ba_ into the account info
    foreach ($data as $key => $value) {
      if ('_party_ba_' == substr($key, 0, 10)) {
        if (!empty($value)) {
          $new_key = substr($key, 10);
          $account_info[$new_key] = $value;
        }
      }
    }

    // find all referenced bank accounts
    $bank_accounts = array();
    $contact_bank_account_id = NULL;
    $contact_bank_account_created = false;
    $reference2instances = array();
    foreach ($references as $reference_type => $reference) {
      $reference2instances[$reference] = array();
      $query = array('version'=>3, 'reference' => $reference, 'reference_type_id' => $reference_type);
      $existing = civicrm_api('BankingAccountReference', 'get', $query);
      if (empty($existing['is_error'])) {
        foreach ($existing['values'] as $account_reference) {
          array_push($reference2instances[$reference], $account_reference);
          if (!isset($bank_accounts[$account_reference['ba_id']])) {
            // load the bank account
            $ba_bao = new CRM_Banking_BAO_BankAccount();
            $ba_bao->get('id', $account_reference['ba_id']);
            $bank_accounts[$account_reference['ba_id']] = $ba_bao;
          }

          // consider this bank account to be ours if the contact id matches
          if (!$contact_bank_account_id && ($ba_bao->contact_id == $contact_id)) {
            $contact_bank_account_id = $ba_bao->id;
          }
        }
      }
    }

    // create new account if it does not yet exist
    if (!$contact_bank_account_id) {
      $ba_bao = new CRM_Banking_BAO_BankAccount();
      $ba_bao->contact_id = $contact_id;
      $ba_bao->description = E::ts("created by CiviBanking");
      $ba_bao->created_date = date('YmdHis');
      $ba_bao->modified_date = date('YmdHis');
      $ba_bao->data_raw = NULL;
      $ba_bao->data_parsed = "{}";
      $ba_bao->save();

      $contact_bank_account_id = $ba_bao->id;
      $bank_accounts[$contact_bank_account_id] = $ba_bao;
      $contact_bank_account_created = true;
    }

    // update bank account data
    $ba_bao = $bank_accounts[$contact_bank_account_id];
    $ba_data = $ba_bao->getDataParsed();
    foreach ($account_info as $key => $value) {
      $ba_data[$key] = $value;
    }
    $ba_bao->setDataParsed($ba_data);
    $ba_bao->save();

    // create references (warn if exists for another contact)
    foreach ($references as $reference_type => $reference) {
      // check the existing
      $reference_already_there = false;
      foreach ($reference2instances[$reference] as $reference_instance) {
        if ($reference_instance['ba_id'] == $contact_bank_account_id) {
          // there is already a reference for 'our' bank account
          $reference_already_there = true;
          break;
        }
      }

      if (!$reference_already_there) {
        // there was no reference to 'our' bank account -> create!
        $query = array( 'version'           => 3,
                        'reference'         => $reference,
                        'reference_type_id' => $reference_type,
                        'ba_id'             => $contact_bank_account_id);
        $result = civicrm_api('BankingAccountReference', 'create', $query);
        if (!empty($result['is_error'])) {
          CRM_Core_Session::setStatus(E::ts("Couldn't create reference. Error was: '%1'", array(1=>$result['error_message'])), E::ts('Error'), 'alert');
        }
      }
    }

    // finally, create some feedback
    if ($contact_bank_account_created) {
      if (count($bank_accounts) > 1) {
        // there are mutiple acccounts referenced by this
        $message = E::ts("The account information of this contact was saved, but it is also used by the following contacts:<br/><ul>%s</ul>");
        $contacts = "";
        foreach ($bank_accounts as $ba_id => $ba_bao) {
          if ($ba_id == $contact_bank_account_id) continue;
          $contact = civicrm_api('Contact', 'getsingle', array('version' => 3, 'id' => $ba_bao->contact_id));
          if (empty($contact['is_error'])) {
            $url = CRM_Utils_System::url('civicrm/contact/view', 'cid='.$ba_bao->contact_id);
            $contacts .= "<li><a href='$url'>".$contact['display_name']."</a></li>";
          }
        }
        CRM_Core_Session::setStatus(sprintf($message, $contacts), E::ts('Warning'), 'warn');
      } else {
        CRM_Core_Session::setStatus(E::ts("The account information of this contact was saved."), E::ts('Account saved'), 'info');
      }
    }
  }
}

